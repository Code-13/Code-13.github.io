<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>Spring-framework源码分析（三）统一资源加载 - 代号十三</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="code-13,代号十三">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/avatar.jpg" type="image/x-icon" />
    <meta name="description" content="关于统一资源和资源加载策略官网对于 org.springframework.core.io.Resource 的一段说明： https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-framework&#x2F;docs&#x2F;5.2.7.RELEASE&#x2F;spring-framework-reference&#x2F;core.html#resources-introduction Java’s standard jav">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-framework源码分析（三）统一资源加载">
<meta property="og:url" content="https://code-13.github.io/blogs/5eef8624.html">
<meta property="og:site_name" content="代号十三">
<meta property="og:description" content="关于统一资源和资源加载策略官网对于 org.springframework.core.io.Resource 的一段说明： https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-framework&#x2F;docs&#x2F;5.2.7.RELEASE&#x2F;spring-framework-reference&#x2F;core.html#resources-introduction Java’s standard jav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/24/20200724105925.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/22/20200722202142.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/22/20200722212413.jpg">
<meta property="article:published_time" content="2020-07-22T11:54:10.000Z">
<meta property="article:modified_time" content="2021-12-24T09:12:03.509Z">
<meta property="article:author" content="代号十三">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Spring-framework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/24/20200724105925.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <link rel="stylesheet" href="/css/style.css?v=1640337217080">
     
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1640337217080">
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/20200708225124.png)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="代号十三" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/avatar.jpg" alt="代号十三"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="代号十三">
            <img src="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/avatar.jpg" alt="代号十三" alt="代号十三">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>12</div>
        <div><span>标签</span>5</div>
        <div><span>分类</span>3</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="https://code-13.github.io/books" title="书海遨游">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                书海遨游
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:code-13.github.io" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/1504682" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/code-13/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JVM-内存分析/">JVM 内存分析</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/MapStruct/">MapStruct</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Spring-framework源码分析/">Spring-framework源码分析</a>
          <span class="category-list-count">9</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MAT/" style="font-size: 10px;">MAT</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/Spring-framework/" style="font-size: 20px;">Spring-framework</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 20px;">源码分析</a>
    </div>
    
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 代号十三
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br> 有点累
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
              <img data-src="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/20/20200720195606.jpg" data-sizes="auto" alt="Spring-framework源码分析（三）统一资源加载" class="lazyload">
              <h1>Spring-framework源码分析（三）统一资源加载</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月22日</a>
    <a><i class="nexmoefont icon-areachart"></i>7.2k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 35 分钟</a>
</div>

      

      <h2 id="关于统一资源和资源加载策略"><a href="#关于统一资源和资源加载策略" class="headerlink" title="关于统一资源和资源加载策略"></a>关于统一资源和资源加载策略</h2><p>官网对于 org.springframework.core.io.Resource 的一段说明： <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/spring-framework-reference/core.html#resources-introduction">https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/spring-framework-reference/core.html#resources-introduction</a></p>
<p><code>Java’s standard java.net.URL class and standard handlers for various URL prefixes, unfortunately, are not quite adequate enough for all access to low-level resources. For example, there is no standardized URL implementation that may be used to access a resource that needs to be obtained from the classpath or relative to a ServletContext. While it is possible to register new handlers for specialized URL prefixes (similar to existing handlers for prefixes such as http:), this is generally quite complicated, and the URL interface still lacks some desirable functionality, such as a method to check for the existence of the resource being pointed to.</code></p>
<p>　　Spring’s Resource interface is meant to be a more capable interface for abstracting access to low-level resources.</p>
<p>　　<code>在 Java 中，将不同来源的资源抽象成 java.net.URL ，即统一资源定位器（Uniform Resource Locator），然后通过注册不同的 handler ( URLStreamHandler )来处理不同来源的资源的读取逻辑，一般 handler 的类型使用不同前缀（协议， Protocol ）来识别，如“file:”“http:” “jar:”等，然而 URL 没有默认定义相对 Classpath 或 ServletContext 等资源的 handler ，虽然可以注册自己的 URLStreamHandler 来解析特定的 URL 前缀（协议）， 比如“classpath:”，然而这需要了解 Url 的实现机制，实现也比较复杂，而且 Url 也没有提供一些基本的方法，如检查当前资源是否存在、检查当前资源是否可读等方法。 因而 Spring 对其内部使用到的资源实现了自己的抽象结构 ： Resource 接口封装底层资源，（《Spring源码深度解析 第二版》，略微修改）然后通过 ResourceLoader 接口来实现 Resource 的加载策略，也即是提供了统一的资源定义和资源加载策略的抽象。通过不同策略进行的所有资源加载，都可以返回统一的抽象给客户端，客户端对资源可以进行的操作，则由 Resource 接口进行界定，具体如何处理，则交由不同来源的资源实现类来实现。</code></p>
<ul>
<li><code>Resource</code> ：提供统一的资源定义抽象，界定了对资源可以进行的处理操作。例如：文件资源（ FileSystemResource ） 、 Classpath 资源（ ClassPathResource ）、 URL 资源（ UrlResource ）、 InputStream 资源（ InputStreamResource ） 、Byte 数组（ ByteArrayResource ）等 。</li>
<li><code>ResourceLoader</code> ：提供统一的资源加载策略抽象，返回统一的 Resource 资源抽象给客户端。</li>
</ul>
<span id="more"></span>

<h2 id="统一资源-Resource"><a href="#统一资源-Resource" class="headerlink" title="统一资源 Resource"></a>统一资源 Resource</h2><h3 id="Resource-接口定义"><a href="#Resource-接口定义" class="headerlink" title="Resource 接口定义"></a>Resource 接口定义</h3><p><code>org.springframework.core.io.Resource</code> 为 Spring 框架用到的所有资源提供了一个统一的抽象接口，它继承了 <code>org.springframework.core.io.InputStreamSource</code> 接口，而 InputStreamSource 接口则用于将对应的资源封装为 Java 的标准 InputStream</p>
<p>Resource 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。 Resource 接口提供的通用方法如下（详情可参考 API 文档 or 源码注释）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 检测资源是否物理形式存在</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 此方法执行确定的存在性检查，而Resource句柄的存在仅保证有效的描述符句柄</span><br><span class="hljs-comment">	 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 资源是否可以被读取</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 为true时，与exists()语义相同，但是读取时仍然可能会失败</span><br><span class="hljs-comment">	 * 但是，为false时，则表示资源一定不能被读取</span><br><span class="hljs-comment">	 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> exists();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表明这个资源是否有已打开流的处理。 如果true ，则此InputStream就不能被多次读取，必须读取和关闭，以避免资源泄漏</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否是文件系统中的文件 File</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFile</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回资源对应的 URL 句柄</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">URL <span class="hljs-title">getURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回资源对应的 URI 句柄</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">URI <span class="hljs-title">getURI</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回资源对应的 File 句柄</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">File <span class="hljs-title">getFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回 ReadableByteChannel</span><br><span class="hljs-comment">     * 每次调用创建一个新的通道</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> ReadableByteChannel <span class="hljs-title">readableChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> Channels.newChannel(getInputStream());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回资源的内容长度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">contentLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资源的最后的修改时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">lastModified</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据资源的相对路径创建对应的资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Resource <span class="hljs-title">createRelative</span><span class="hljs-params">(String relativePath)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资源的文件名，不带路径信息的文件名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function">String <span class="hljs-title">getFilename</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资源的描述信息，用来在错误处理中打印信息 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>InputStreamSource 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 返回底层资源的标准输入流。每次调用都返回新的输入流，调用者必须负责关闭输入流。</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function">InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Resource-继承体系"><a href="#Resource-继承体系" class="headerlink" title="Resource 继承体系"></a>Resource 继承体系</h3><p><img src="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/24/20200724105925.png"></p>
<p>底层资源可能会有各种来源，像文件系统、Url、classpath，甚至是 servletcontext 等，因此，Resource 需要根据资源的不同类型提供不同的具体实现，如 文件（ FileSystemResource ） 、 Classpath 资源（ ClassPathResource ）、 URL 资源（ UrlResource ）、 InputStream 资源（ InputStreamResource ） 、Byte 数组（ ByteArrayResource ）等。</p>
<p>常见的 Resource 实现类：(摘自文档，简单的翻译一下)</p>
<ul>
<li><code>ClassPathResource</code> ：class path 类型资源的封装实现类，内部使用给定的 ClassLoader 或者给定的 Class 进行资源加载。<ul>
<li>Resource implementation for class path resources. Uses either a given ClassLoader or a given Class for loading resources.</li>
<li>Supports resolution as java.io.File if the class path resource resides in the file system, but not for resources in a JAR. Always supports resolution as URL.</li>
</ul>
</li>
</ul>
<ul>
<li><code>FileSystemResource</code> ：java.io.File 和 java.nio.file.Path 类型资源的封装实现类，用于处理文件系统资源。支持 File 和 Url 的形式。从 Spring Framework 5.0 开始使用 NIO2 进行 读/写 交互。从 5.1 开始，还可能是通过 Path 句柄来进行构造，这种场景下它将通过 NIO2进行所有的文件系统交互；只有通过 getFile() 时才转转为 File。<ul>
<li>Resource implementation for java.io.File and java.nio.file.Path handles with a file system target. Supports resolution as a File and also as a URL. Implements the extended WritableResource interface.</li>
<li>Note: As of Spring Framework 5.0, this Resource implementation uses NIO.2 API for read/write interactions. As of 5.1, it may be constructed with a Path handle in which case it will perform all file system interactions via NIO.2, only resorting to File on getFile().</li>
</ul>
</li>
</ul>
<ul>
<li><code>ByteArrayResource</code> ：对 byte 数组的封装实现类，会根据给定的 byte 数组构造一个对应的 ByteArrayInputStream 作为 InputStream 类型的返回。<ul>
<li>Resource implementation for a given byte array.</li>
<li>Creates a ByteArrayInputStream for the given byte array.</li>
<li>Useful for loading content from any given byte array, without having to resort to a single-use InputStreamResource. Particularly useful for creating mail attachments from local content, where JavaMail needs to be able to read the stream multiple times.</li>
</ul>
</li>
</ul>
<ul>
<li><code>UrlResource</code> ：对 java.net.URL 类型资源的封装实现类。支持 URL 和 File（使用 file: 协议的时候）的形式<ul>
<li>Resource implementation for java.net.URL locators. Supports resolution as a URL and also as a File in case of the “file:” protocol.</li>
</ul>
</li>
</ul>
<ul>
<li><code>InputStreamResource</code> ：将给定的 InputStream 作为资源的封装实现类。只有当其他类型都无法使用的时候才会用到，尽量使用相匹配的类型进行处理。<ul>
<li>Resource implementation for a given InputStream.</li>
<li>Should only be used if no other specific Resource implementation is applicable. In particular, prefer ByteArrayResource or any of the file-based Resource implementations where possible.</li>
<li>In contrast to other Resource implementations, this is a descriptor for an already opened resource - therefore returning true from isOpen(). Do not use an InputStreamResource if you need to keep the resource descriptor somewhere, or if you need to read from a stream multiple times.</li>
</ul>
</li>
</ul>
<h3 id="AbstractResource"><a href="#AbstractResource" class="headerlink" title="AbstractResource"></a>AbstractResource</h3><p><strong><code>AbstractResource</code> 为 <code>Resource</code> 接口的默认实现，它实现了 <code>Resource</code> 接口的大部分的公共实现，作为 <code>Resource</code> 接口中的重中之重，其定义如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Resource</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查文件是否存在，或者检查有对应的流 InputStream 存在，此时需要关闭流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Try file existence: can we find the file in the file system?</span><br>        <span class="hljs-comment">// 先判断文件 File 是否存在：基于 File 的判断</span><br>        <span class="hljs-keyword">if</span> (isFile()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> getFile().exists();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>                Log logger = LogFactory.getLog(getClass());<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Could not retrieve File for existence check of &quot;</span> + getDescription(), ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Fall back to stream existence: can we open the stream?</span><br>        <span class="hljs-comment">// 其次检查是否是可以打开的流 InputStream：基于 InputStream 的判断</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            getInputStream().close();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            Log logger = LogFactory.getLog(getClass());<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Could not retrieve InputStream for existence check of &quot;</span> + getDescription(), ex);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对于存在的资源，此实现总是返回true(从5.1版修订)，通过 exists() 进行判断</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> exists();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直接返回 false，表示未打开</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直接返回 false，表示不为 File，需要子类重写判断</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFile</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直接抛出 FileNotFoundException 异常，需要子类实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> URL <span class="hljs-title">getURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(getDescription() + <span class="hljs-string">&quot; cannot be resolved to URL&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于 getURL() 返回的 URL 构建 URI</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> URI <span class="hljs-title">getURI</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        URL url = getURL();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> ResourceUtils.toURI(url);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (URISyntaxException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedIOException(<span class="hljs-string">&quot;Invalid URI [&quot;</span> + url + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直接抛出 FileNotFoundException 异常，需要子类实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> File <span class="hljs-title">getFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(getDescription() + <span class="hljs-string">&quot; cannot be resolved to absolute file path&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回根据 getInputStream() 的结果构建的 ReadableByteChannel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ReadableByteChannel <span class="hljs-title">readableChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> Channels.newChannel(getInputStream());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取资源的长度。这里是通过全部读取来计算资源的字节长度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">contentLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        InputStream is = getInputStream();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">long</span> size = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">256</span>];<br>            <span class="hljs-keyword">int</span> read;<br>            <span class="hljs-keyword">while</span> ((read = is.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                size += read;<br>            &#125;<br>            <span class="hljs-keyword">return</span> size;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                is.close();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>                Log logger = LogFactory.getLog(getClass());<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Could not close content-length InputStream for &quot;</span> + getDescription(), ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资源文件的最后的修改时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lastModified</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File fileToCheck = getFileForLastModifiedCheck();<br>        <span class="hljs-keyword">long</span> lastModified = fileToCheck.lastModified();<br>        <span class="hljs-keyword">if</span> (lastModified == <span class="hljs-number">0L</span> &amp;&amp; !fileToCheck.exists()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(getDescription() +<br>                    <span class="hljs-string">&quot; cannot be resolved in the file system for checking its last-modified timestamp&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lastModified;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回相应的资源文件用于检查最后修改时间，内部直接使用 getFile() 实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> File <span class="hljs-title">getFileForLastModifiedCheck</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> getFile();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直接抛出 FileNotFoundException 异常，需要子类实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">createRelative</span><span class="hljs-params">(String relativePath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;Cannot create a relative resource for &quot;</span> + getDescription());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取资源名称，这里直接返回 null ，需要子类实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFilename</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object other)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == other || (other <span class="hljs-keyword">instanceof</span> Resource &amp;&amp;<br>                ((Resource) other).getDescription().equals(getDescription())));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getDescription().hashCode();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里获取资源的描述信息作为返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getDescription();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Spring 的很多顶层设计接口，都会有相关的 Abstract / Default 子类来处理一些典型的预实现，如果需要自定义这些接口的继承类，比如这里需要自定义的 Resource ，则建议直接继承 AbstractResource ，然后根据具体的资源特性重写相关的方法，而不是直接继承顶层接口 Resource，重写全部方法。</li>
</ul>
<h2 id="统一资源加载-ResourceLoader"><a href="#统一资源加载-ResourceLoader" class="headerlink" title="统一资源加载 ResourceLoader"></a>统一资源加载 ResourceLoader</h2><p><code>org.springframework.core.io.ResourceLoader</code> 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为 <strong>统一资源定位器</strong></p>
<h3 id="ResourceLoader接口定义"><a href="#ResourceLoader接口定义" class="headerlink" title="ResourceLoader接口定义"></a>ResourceLoader接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourceLoader</span> </span>&#123;<br>    <span class="hljs-comment">/** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot;. */</span><br>    <span class="hljs-comment">// 用于从类路径加载的伪URL前缀:“classpath:”</span><br>    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据指定的资源路径返回对应的资源 Resource，该 Resource 句柄</span><br><span class="hljs-comment">     * 应该总是一个可重用的资源描述符，允许多个 Resource.getInputStream()调用。</span><br><span class="hljs-comment">     * 需要注意的是该 Resource 句柄 并不确保对应的资源一定存在，需要调用</span><br><span class="hljs-comment">     * Resource.exists() 来进行实际的判断。</span><br><span class="hljs-comment">     * 该方法支持以下这些模式的资源加载：</span><br><span class="hljs-comment">     *      · 全限定路径 URL 位置的资源，如：&quot;file:C:/test.dat&quot;.</span><br><span class="hljs-comment">     *      · classpath 类路径位置的资源，如 &quot;classpath:test.dat&quot;.</span><br><span class="hljs-comment">     *      · 相对路径的资源，如 &quot;WEB-INF/test.dat&quot;. 这种情况下会根据不同实现返回不同的 Resource 实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回当前 ResourceLoader 所用到的 ClassLoader ，</span><br><span class="hljs-comment">     * 需要直接访问 ClassLoader 的客户端，可以通过 ResourceLoader 以这种统一的方式来直接获取 ClassLoader 。</span><br><span class="hljs-comment">     * Resource 中的实现类 ClassPathResource 可以根据指定的 ClassLoader 进行资源加载</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function">ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ResourceLoader-的继承体系结构图"><a href="#ResourceLoader-的继承体系结构图" class="headerlink" title="ResourceLoader 的继承体系结构图"></a>ResourceLoader 的继承体系结构图</h3><p><img src="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/22/20200722202142.png"></p>
<h3 id="DefaultResourceLoader"><a href="#DefaultResourceLoader" class="headerlink" title="DefaultResourceLoader"></a>DefaultResourceLoader</h3><h4 id="DefaultResourceLoader-的内部属性"><a href="#DefaultResourceLoader-的内部属性" class="headerlink" title="DefaultResourceLoader 的内部属性"></a>DefaultResourceLoader 的内部属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类加载器</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> ClassLoader classLoader;<br><br><span class="hljs-comment">// 用户自定义的特定协议资源加载解析策略接口，用于自定义加载策略</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;ProtocolResolver&gt; protocolResolvers = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 各种类型资源的缓存</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Map&lt;Resource, ?&gt;&gt; resourceCaches = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<h4 id="DefaultResourceLoader-的构造函数"><a href="#DefaultResourceLoader-的构造函数" class="headerlink" title="DefaultResourceLoader 的构造函数"></a>DefaultResourceLoader 的构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 无参构造函数，这里内部实际上就是优先使用 Thread.currentThread().getContextClassLoader()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultResourceLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.classLoader = ClassUtils.getDefaultClassLoader();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指定 ClassLoader 的带参构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultResourceLoader</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.classLoader = classLoader;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置指定的 ClassLoader，也可以使用默认的 Thread.currentThread().getContextClassLoader()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClassLoader</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.classLoader = classLoader;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.classLoader != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.classLoader : ClassUtils.getDefaultClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>DefaultResourceLoader 的构造函数也比较简单，一个不带参的空构造函数和一个指定 ClassLoader 的构造函数。</p>
<p>ClassLoader 还可以通过 setClassLoader() 来进行指定，这里可以使用 <code>ClassUtils.getDefaultClassLoader()</code>，内部也是优先使用 <code>Thread.currentThread().getContextClassLoader()</code> 来获取，也即是执行线程的 ClassLoader。 </p>
<h4 id="ProtocolResolver-自定义的资源加载策略"><a href="#ProtocolResolver-自定义的资源加载策略" class="headerlink" title="ProtocolResolver 自定义的资源加载策略"></a>ProtocolResolver 自定义的资源加载策略</h4><p><code>org.springframework.core.io.ProtocolResolver</code> 是特定协议的资源加载解析策略接口。</p>
<p>用作 <code>DefaultResourceLoader</code> 的SPI，允许在不继承 <code>DefaultResourceLoader</code>(或 <code>ApplicationContext</code> 实现类)的情况下处理自定义协议。</p>
<p>这样，如果需要自定义资源 <code>Resource</code> 和相应的加载策略，则可以通过继承 <code>AbstractResource</code> 来实现对应的资源，然后再增加相关的 <code>ProtocolResolver</code> 来实现对应的资源定位加载策略，这样就不需要再继承 <code>DefaultResourceLoader</code> 了。</p>
<p>ProtocolResolver接口定于如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A resolution strategy for protocol-specific resource handles.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Used as an SPI for &#123;<span class="hljs-doctag">@link</span> DefaultResourceLoader&#125;, allowing for</span><br><span class="hljs-comment"> * custom protocols to be handled without subclassing the loader</span><br><span class="hljs-comment"> * implementation (or application context implementation).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;特定协议的资源加载解决策略接口。</span><br><span class="hljs-comment"> * 用作 DefaultResourceLoader 的SPI，允许在不继承 DefaultResourceLoader(或 ApplicationContext 实现类)的情况下处理自定义协议。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 4.3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> DefaultResourceLoader#addProtocolResolver</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProtocolResolver</span> </span>&#123;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Resolve the given location against the given resource loader</span><br><span class="hljs-comment">    * if this implementation&#x27;s protocol matches.</span><br><span class="hljs-comment">    * &lt;p&gt;根据指定的 ResourceLoader 来解析对应的资源路径，若成功则返回相应的 Resource</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> location the user-specified resource location 指定的资源路径</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resourceLoader the associated resource loader 指定的 ResourceLoader</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> a corresponding &#123;<span class="hljs-doctag">@code</span> Resource&#125; handle if the given location</span><br><span class="hljs-comment">    * matches this resolver&#x27;s protocol, or &#123;<span class="hljs-doctag">@code</span> null&#125; otherwise</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function">Resource <span class="hljs-title">resolve</span><span class="hljs-params">(String location, ResourceLoader resourceLoader)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Spring 并没有 <code>ProtocolResolver</code> 接口的任何实现类，这个完全需要用户自己进行定义实现，然后再通过 <code>DefaultResourceLoader.addProtocolResolver(ProtocolResolver resolver)</code> 注册到 Spring 中，该方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Register the given resolver with this resource loader, allowing for</span><br><span class="hljs-comment"> * additional protocols to be handled.</span><br><span class="hljs-comment"> * &lt;p&gt;Any such resolver will be invoked ahead of this loader&#x27;s standard</span><br><span class="hljs-comment"> * resolution rules. It may therefore also override any default rules.</span><br><span class="hljs-comment"> * &lt;p&gt;注册自定义的特定协议资源加载解决器，允许处理其他协议的资源</span><br><span class="hljs-comment"> * 需要注意的是这些解析器在资源加载时会先执行，因此可能会覆盖其他默认的加载规则</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 4.3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #getProtocolResolvers()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProtocolResolver</span><span class="hljs-params">(ProtocolResolver resolver)</span> </span>&#123;<br>    Assert.notNull(resolver, <span class="hljs-string">&quot;ProtocolResolver must not be null&quot;</span>);<br>    <span class="hljs-keyword">this</span>.protocolResolvers.add(resolver);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="getResource-方法"><a href="#getResource-方法" class="headerlink" title="getResource() 方法"></a>getResource() 方法</h4><ul>
<li>getResource(String location) 是 DefaultResourceLoader 的核心方法</li>
</ul>
<ul>
<li>它会根据提供的 location 返回对应的 Resource</li>
</ul>
<ul>
<li>DefaultResourceLoader 的子类 ClassRelativeResourceLoader 和 FileSystemResourceLoader 并没有覆盖这个方法，因此 ResourceLoader 的资源加载策略就是依靠 DefaultResourceLoader 来实现的</li>
</ul>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span> </span>&#123;<br>    Assert.notNull(location, <span class="hljs-string">&quot;Location must not be null&quot;</span>);<br><br>    <span class="hljs-comment">// 首先，先使用自定义的加载解析策略 ProtocolResolver 来加载资源，解析得到就直接返回相应资源</span><br>    <span class="hljs-keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;<br>        Resource resource = protocolResolver.resolve(location, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> resource;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 然后，以 / 开头的资源，则返回 ClassPathContextResource 类型的资源</span><br>    <span class="hljs-keyword">if</span> (location.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> getResourceByPath(location);<br>    &#125;<br>    <span class="hljs-comment">// 之后，以 classpath: 开头的，返回 ClassPathResource 类型的资源</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断是否为文件 Url，是则返回 FileUrlResource 类型的资源；否则返回 UrlResource 类型的资源</span><br>            <span class="hljs-comment">// Try to parse the location as a URL...</span><br>            URL url = <span class="hljs-keyword">new</span> URL(location);<br>            <span class="hljs-keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="hljs-keyword">new</span> FileUrlResource(url) : <span class="hljs-keyword">new</span> UrlResource(url));<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (MalformedURLException ex) &#123;<br>            <span class="hljs-comment">// 最后，则返回 ClassPathContextResource 类型的资源</span><br>            <span class="hljs-comment">// No URL -&gt; resolve as resource path.</span><br>            <span class="hljs-keyword">return</span> getResourceByPath(location);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>getResourceByPath(String path) 方法定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认直接返回 ClassPathContextResource，子类可以覆盖重写</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title">getResourceByPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassPathContextResource(path, getClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="完整的加载定位策略"><a href="#完整的加载定位策略" class="headerlink" title="完整的加载定位策略"></a>完整的加载定位策略</h4><ul>
<li>首先，使用自定义的加载解析策略 ProtocolResolver 来加载资源，解析得到就直接返回相应资源</li>
<li>然后，以 / 开头的资源，则调用 getResourceByPath(String path) 返回 ClassPathContextResource 类型的资源</li>
<li>之后，以 classpath: 开头的，返回 ClassPathResource 类型的资源</li>
<li>接着，判断是否为文件 Url，是则返回 FileUrlResource 类型的资源；否则返回 UrlResource 类型的资源</li>
<li>最后，若出现了 MalformedURLException 异常，则还是委派 getResourceByPath(String path) 返回 ClassPathContextResource 类型的资源。这样就基本完成了资源的定位加载。</li>
</ul>
<h3 id="FileSystemResourceLoader"><a href="#FileSystemResourceLoader" class="headerlink" title="FileSystemResourceLoader"></a>FileSystemResourceLoader</h3><p>如果是文件系统的文件资源，<code>DefaultResourceLoader.getResourceByPath(String path)</code> 的处理是不恰当的。这个时候就需要使用 <code>org.springframework.core.io.FileSystemResourceLoader</code> 了，它重写了 <code>DefaultResourceLoader.getResourceByPath(String path)</code> 方法，返回 <code>FileSystemResource</code> 类型的资源以便可以从文件系统进行加载，最终得到我们需要的资源类型</p>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystemResourceLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultResourceLoader</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回 FileSystemContextResource 类型的资源</span><br><span class="hljs-comment">     * 将资源路径解析为文件系统路径，以 / 开头的会被解析为 VM 当前工作目录的相对路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title">getResourceByPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>        <span class="hljs-comment">// 截取开头的 /，会当作 context 上下文的额相对路径</span><br>          <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>            path = path.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FileSystemContextResource(path);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过实现 ContextResource 接口显式地表示上下文相关路径的 FileSystemResource</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystemContextResource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileSystemResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextResource</span> </span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileSystemContextResource</span><span class="hljs-params">(String path)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(path);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回文件资源的路径</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPathWithinContext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getPath();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>FileSystemContextResource</code> 是 <code>FileSystemResourceLoader</code> 的内部类，它继承了 <code>FileSystemResource</code> 类，还实现了 <code>ContextResource</code> 接口，既可以表示实际文件系统的资源，也可以表示 context <code>环境相对路径的资源。FileSystemContextResource</code> 的构造函数也比较简单，直接调用父类 <code>FileSystemResourceLoader</code> 的构造函数来实现。</p>
<h3 id="ClassRelativeResourceLoader"><a href="#ClassRelativeResourceLoader" class="headerlink" title="ClassRelativeResourceLoader"></a>ClassRelativeResourceLoader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ResourceLoader 的实现类，将普通的资源路径解析为给定 java.lang.Class 相关的资源，</span><br><span class="hljs-comment"> * 用于解析加载 Class 所在包或所在包的子包下的资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassRelativeResourceLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultResourceLoader</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据指定的 class 创建 ClassRelativeResourceLoader 实例，</span><br><span class="hljs-comment">     * 内部会通过 class 来获取对应的 ClassLoader，这个 ClassLoader 可以用于</span><br><span class="hljs-comment">     * 自定义解析策略的加载，也可以用于 ClassPathResource 类型的资源（协议是 classpath:），</span><br><span class="hljs-comment">     * 参考 DefaultResourceLoader.getResource()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassRelativeResourceLoader</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>        Assert.notNull(clazz, <span class="hljs-string">&quot;Class must not be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>        setClassLoader(clazz.getClassLoader());<br>    &#125;<br><br>    <span class="hljs-comment">// 返回 ClassRelativeContextResource 类型的资源</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title">getResourceByPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassRelativeContextResource(path, <span class="hljs-keyword">this</span>.clazz);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过实现 ContextResource 接口显式地表示上下文相关路径的 ClassRelativeContextResource</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassRelativeContextResource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassPathResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassRelativeContextResource</span><span class="hljs-params">(String path, Class&lt;?&gt; clazz)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(path, clazz);<br>            <span class="hljs-keyword">this</span>.clazz = clazz;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回文件资源的路径</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPathWithinContext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getPath();<br>        &#125;<br><br>        <span class="hljs-comment">// 根据资源的相对路径创建对应的资源，内部会将相对路径拼接进去</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">createRelative</span><span class="hljs-params">(String relativePath)</span> </span>&#123;<br>            String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassRelativeContextResource(pathToUse, <span class="hljs-keyword">this</span>.clazz);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h3><p><code>ResourceLoader</code> 的 <code>Resource getResource(String location)</code> 方法每次只返回一个 Resource，无法加载多个资源，所以一般会是对应到具体的某个资源文件。如果需要加载多个资源的，则需要用 <code>ResourceLoader</code> 的另一个扩展类 <code>org.springframework.core.io.support.ResourcePatternResolver</code>，它支持根据指定的资源路径一次返回多个 <code>Resource</code> 实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourcePatternResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceLoader</span> </span>&#123;<br><br>    String CLASSPATH_ALL_URL_PREFIX = <span class="hljs-string">&quot;classpath*:&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回指定路径的 Resource 数组实例对象</span><br><span class="hljs-comment">     */</span><br>    Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="PathMatchingResourcePatternResolver"><a href="#PathMatchingResourcePatternResolver" class="headerlink" title="PathMatchingResourcePatternResolver"></a>PathMatchingResourcePatternResolver</h3><p><code>PathMatchingResourcePatternResolver</code> 为 <code>ResourcePatternResolver</code> 最常用的子类，它除了支持 <code>ResourceLoader</code> 和 <code>ResourcePatternResolver</code> 新增的 <code>classpath*:</code> 前缀外，还支持 Ant 风格的路径匹配模式（类似于 **/*.xml）。</p>
<h4 id="构造函数和属性"><a href="#构造函数和属性" class="headerlink" title="构造函数和属性"></a>构造函数和属性</h4><p>PathMatchingResourcePatternResolver 提供了3个构造函数，都与 ResourceLoader 有关：</p>
<ul>
<li>实例化时需要指定 ResourceLoader，默认是 DefaultResourceLoader。</li>
<li>PathMatcher pathMatcher 属性，默认是 AntPathMatcher，Ant 类型的路径匹配实现类 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内置的 ResourceLoader 资源加载定位器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ResourceLoader resourceLoader;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Ant 路径匹配器，用于支持 Ant 类型的路径匹配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> PathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有指定的话就是用默认的 DefaultResourceLoader</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathMatchingResourcePatternResolver</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.resourceLoader = <span class="hljs-keyword">new</span> DefaultResourceLoader();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathMatchingResourcePatternResolver</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> </span>&#123;<br>    Assert.notNull(resourceLoader, <span class="hljs-string">&quot;ResourceLoader must not be null&quot;</span>);<br>    <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathMatchingResourcePatternResolver</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.resourceLoader = <span class="hljs-keyword">new</span> DefaultResourceLoader(classLoader);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="getResource-方法-1"><a href="#getResource-方法-1" class="headerlink" title="getResource 方法"></a>getResource 方法</h4><p><code>getResource</code> 直接通过委托给 <code>ResourceLoader</code> 来进行加载，也即是默认的 <code>DefaultResourceLoader</code> 进行加载： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getResourceLoader().getClassLoader();<br>&#125;<br><br><span class="hljs-comment">// 使用内置的 ResourceLoader 进行加载，如果不是 ant 风格的路径，应该都是单一的 Resource</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getResourceLoader().getResource(location);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="getResources-方法"><a href="#getResources-方法" class="headerlink" title="getResources 方法"></a>getResources 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException &#123;<br>    Assert.notNull(locationPattern, <span class="hljs-string">&quot;Location pattern must not be null&quot;</span>);<br>    <span class="hljs-comment">// 以 &quot;classpath*:&quot; 开头的路径</span><br>    <span class="hljs-keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;<br>        <span class="hljs-comment">// 路径包含通配符</span><br>        <span class="hljs-comment">// a class path resource (multiple resources for same name possible)</span><br>        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;<br>            <span class="hljs-comment">// a class path resource pattern</span><br>            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>        &#125;<span class="hljs-comment">// 路径不含通配符</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// all class path resources with the given name</span><br>            <span class="hljs-keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));<br>        &#125;<br>    &#125;<span class="hljs-comment">// 不以 &quot;classpath*:&quot; 开头的路径</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Generally only look for a pattern after a prefix here,</span><br>        <span class="hljs-comment">// and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol.</span><br>        <span class="hljs-comment">// 通常只在这里查找前缀后的模式，而在Tomcat中仅在“*/”分隔符后查找其“war:”协议。</span><br>        <span class="hljs-keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="hljs-string">&quot;war:&quot;</span>) ? locationPattern.indexOf(<span class="hljs-string">&quot;*/&quot;</span>) + <span class="hljs-number">1</span> :<br>                locationPattern.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 路径包含通配符</span><br>        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;<br>            <span class="hljs-comment">// a file pattern</span><br>            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>        &#125;<span class="hljs-comment">// 不包含通配符，表示单一的资源</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// a single resource with the given name</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>逻辑流程如下：</p>
<ul>
<li>路径包含通配符的，不管有没有 “classpath*:” 开头的，都调用 findPathMatchingResources(String locationPattern) 进行多个资源的加载；</li>
<li>以 “classpath*:” 开头，但路径不包含通配符的，则调用 findAllClassPathResources(String location) 进行加载</li>
<li>不是 “classpath*:” 开头，也不包含通配符，那么理论上应该是某个资源路径，直接使用 ResourceLoader 来进行加载。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2020/07/22/20200722212413.jpg"></p>
<h4 id="findAllClassPathResources-方法"><a href="#findAllClassPathResources-方法" class="headerlink" title="findAllClassPathResources() 方法"></a>findAllClassPathResources() 方法</h4><p>以 “classpath*:” 开头，但路径不包含通配符的，则调用 findAllClassPathResources(String location) 进行加载，该方法返回 classes 路径下和所有 jar 包中与路径匹配的所有资源。</p>
<p>这种情况下比较常见的是不同的 jar 包但是相同路径的配置文件，例如，当前项目有个 /spring/app-service.xml，需要引用内部团队其他关联依赖 B.jar ，而且 B.jar 中也有同名的配置文件 /spring/app-service.xml，如果需要都加载，那就可以使用 classpath*:/spring/app-service.xml 来进行配置和加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过类加载器找到 classes 路径和所有 jar 包中与给定路径相匹配的资源，</span><br><span class="hljs-comment"> * 委托给 doFindAllClassPathResources(String) 进行实际的处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="hljs-keyword">throws</span> IOException &#123;<br>    String path = location;<br>    <span class="hljs-comment">// 去掉开头的 / ，因此路径中有没有前导 / 都没有影响，都是相对路径</span><br>    <span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        path = path.substring(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 进行实际的资源定位处理，真正执行加载所有 classpath 资源</span><br>    Set&lt;Resource&gt; result = doFindAllClassPathResources(path);<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Resolved classpath location [&quot;</span> + location + <span class="hljs-string">&quot;] to resources &quot;</span> + result);<br>    &#125;<br>    <span class="hljs-comment">// 转换为 Resource[] 返回</span><br>    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> Resource[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;通过类加载器找到 classes 路径和所有 jar 包中与给定路径相匹配的资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;Resource&gt; <span class="hljs-title">doFindAllClassPathResources</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">16</span>);<br>    ClassLoader cl = getClassLoader();<br>    <span class="hljs-comment">// 1. 通过 ClassLoader 加载指定路径下的所有资源</span><br>    Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="hljs-keyword">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));<br>    <span class="hljs-comment">// 2.</span><br>    <span class="hljs-keyword">while</span> (resourceUrls.hasMoreElements()) &#123;<br>        URL url = resourceUrls.nextElement();<br>        <span class="hljs-comment">// 将 URL 转换成对应的 UrlResource</span><br>        result.add(convertClassLoaderURL(url));<br>    &#125;<br>    <span class="hljs-comment">// 3. 加载路径下所有的 jar 包</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(path)) &#123;<br>        <span class="hljs-comment">// The above result is likely to be incomplete, i.e. only containing file system references.</span><br>        <span class="hljs-comment">// We need to have pointers to each of the jar files on the classpath as well...</span><br>        addAllClassLoaderJarRoots(cl, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将 ClassLoader 返回的给定 URL 转换成 Resource，默认是 UrlResource</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title">convertClassLoaderURL</span><span class="hljs-params">(URL url)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UrlResource(url);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上执行加载的是 doFindAllClassPathResources(String path)，处理过程如下：</p>
<p>通过 ClassLoader 进行资源的加载，如果实例化 PathMatchingResourcePatternResolver 时已指定了 ResourceLoader，则使用这个ResourceLoader 的 ClassLoader 作为委托对象，通过调用其 getResources(String name) 方法来进行处理，否则通过 ClassLoader.getSystemResources(String name) 来进行处理。</p>
<p>ClassLoader.getResources()如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;URL&gt; <span class="hljs-title">getResources</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="hljs-keyword">new</span> Enumeration&lt;?&gt;[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        tmp[<span class="hljs-number">0</span>] = parent.getResources(name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tmp[<span class="hljs-number">0</span>] = getBootstrapResources(name);<br>    &#125;<br>    tmp[<span class="hljs-number">1</span>] = findResources(name);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里比较明显，如果 ClassLoader 有父类加载器，则通过父类加载器迭代加载获取资源，直至最后则是调用 getBootstrapResources(name) 进行资源获取。</p>
<ol start="2">
<li>迭代遍历 1 中获取到的 URL 集合资源，通过 convertClassLoaderURL(URL url) 将 URL 转换成 UrlResource 实例对象。</li>
<li>如果路径 path 为””（classpath*: 或者 classpath*:/），则通过 addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) 方法加载路径下所有 jar 包的资源</li>
</ol>
<h4 id="findPathMatchingResources-方法"><a href="#findPathMatchingResources-方法" class="headerlink" title="findPathMatchingResources() 方法"></a>findPathMatchingResources() 方法</h4><p>路径中包含通配符的，都是使用这个方法进行资源的加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;通过 Ant 风格的 PathMatcher 来查找匹配给定路径的所有资源，</span><br><span class="hljs-comment"> * 支持 在 jar 包、zip 文件、和文件系统中查找相关资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 确定根路径和子路径</span><br>    String rootDirPath = determineRootDir(locationPattern);<br>    String subPattern = locationPattern.substring(rootDirPath.length());<br>    <span class="hljs-comment">// 获取根路径下的资源</span><br>    Resource[] rootDirResources = getResources(rootDirPath);<br>    Set&lt;Resource&gt; result = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 迭代遍历</span><br>    <span class="hljs-keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;<br>        rootDirResource = resolveRootDirResource(rootDirResource);<br>        URL rootDirUrl = rootDirResource.getURL();<br>        <span class="hljs-comment">// bundle 类型的资源</span><br>        <span class="hljs-keyword">if</span> (equinoxResolveMethod != <span class="hljs-keyword">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="hljs-string">&quot;bundle&quot;</span>)) &#123;<br>            URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="hljs-keyword">null</span>, rootDirUrl);<br>            <span class="hljs-keyword">if</span> (resolvedUrl != <span class="hljs-keyword">null</span>) &#123;<br>                rootDirUrl = resolvedUrl;<br>            &#125;<br>            rootDirResource = <span class="hljs-keyword">new</span> UrlResource(rootDirUrl);<br>        &#125;<br>        <span class="hljs-comment">// vfs 类型的资源</span><br>        <span class="hljs-keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;<br>            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));<br>        &#125;<br>        <span class="hljs-comment">// jar 类型的资源</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123;<br>            result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));<br>        &#125;<br>        <span class="hljs-comment">// 其他资源类型</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Resolved location pattern [&quot;</span> + locationPattern + <span class="hljs-string">&quot;] to resources &quot;</span> + result);<br>    &#125;<br>    <span class="hljs-comment">// 转成 Resource 数组</span><br>    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> Resource[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法分两部</p>
<ul>
<li>确定目录，获取该目录下得所有资源</li>
<li>在所获得的所有资源中进行迭代匹配获取我们想要的资源。</li>
</ul>
<p>在这个方法里面我们要关注两个方法，一个是 <code>determineRootDir()</code>,一个是 <code>doFindPathMatchingFileResources()</code>。</p>
<h4 id="determineRootDir-方法"><a href="#determineRootDir-方法" class="headerlink" title="determineRootDir()方法"></a>determineRootDir()方法</h4><p>determineRootDir 方法主要用于确认根路径： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;确定指定路径的根路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineRootDir</span><span class="hljs-params">(String location)</span> </span>&#123;<br>    <span class="hljs-comment">// 冒号之后一位，即协议后面的位置</span><br>    <span class="hljs-keyword">int</span> prefixEnd = location.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 目录结束位置</span><br>    <span class="hljs-keyword">int</span> rootDirEnd = location.length();<br>    <span class="hljs-comment">// 循环判断是否有分隔符，如果有，则截断最后一个 / 之后的部分</span><br>    <span class="hljs-comment">// 例如 classpath*:spring/*-service.xml，循环判断后剩下 spring/ 已经不包含通配符了</span><br>    <span class="hljs-comment">// 如果是 classpath*:*-service.xml，则会出现 rootDirEnd == 0 的情况</span><br>    <span class="hljs-keyword">while</span> (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) &#123;<br>        <span class="hljs-comment">// 通配符至少占 1 个，再加上分隔符，所以 -2；最后 +1 表示返回结果要包含分隔符</span><br>        rootDirEnd = location.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>, rootDirEnd - <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将 prefixEnd 的值赋给 rootDirEnd，也即是冒号后一位</span><br>    <span class="hljs-keyword">if</span> (rootDirEnd == <span class="hljs-number">0</span>) &#123;<br>        rootDirEnd = prefixEnd;<br>    &#125;<br>    <span class="hljs-comment">// 截取根目录</span><br>    <span class="hljs-keyword">return</span> location.substring(<span class="hljs-number">0</span>, rootDirEnd);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>确定根路径如下:</p>
<table>
<thead>
<tr>
<th>原路径</th>
<th>根路径</th>
</tr>
</thead>
<tbody><tr>
<td>classpath*:spring/a*/*-service.xml</td>
<td>classpath*:spring/</td>
</tr>
<tr>
<td>classpath*:spring/a/*-service.xml</td>
<td>classpath*:spring/a/</td>
</tr>
<tr>
<td>classpath*:*-service.xml</td>
<td>classpath*:</td>
</tr>
</tbody></table>
<h4 id="doFindPathMatchingXxxResources-方法"><a href="#doFindPathMatchingXxxResources-方法" class="headerlink" title="doFindPathMatchingXxxResources() 方法"></a>doFindPathMatchingXxxResources() 方法</h4><p>这个指的是特定类型资源的全部加载，只要是 findPathMatchingResources 方法中用到的这3个</p>
<ul>
<li>doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirURL, String subPattern)</li>
<li>doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)</li>
<li>VfsResourceMatchingDelegate.findMatchingResources(URL rootDirURL, String locationPattern, PathMatcher pathMatcher)</li>
</ul>
<p>对于这几个方法的分析，可以参考以下文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/question-sky/p/6959493.html">Spring源码情操陶冶-PathMatchingResourcePatternResolver路径资源匹配溶解器</a><br><a target="_blank" rel="noopener" href="http://www.blogjava.net/DLevin/archive/2012/12/01/392337.html">《深入 Spring IoC 源码之 ResourceLoader》</a><br><a target="_blank" rel="noopener" href="http://www.coderli.com/spring-wildpath-parse/">《Spring 源码学习 —— 含有通配符路径解析（上）》</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。</li>
<li>AbstractResource 为 Resource 的默认实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。</li>
<li>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。</li>
<li>DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 Resource getResource(String location) 也实现了 Resource[] getResources(String locationPattern)。</li>
<li>Resource 和 ResourceLoader 相关接口和实现类都是在 spring-core 包里面，是比较核心的基础功能。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/index.html">Spring-framework 5.2.7.RELEASE 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wpbxin/p/13061470.htm">Spring5源码分析(005)——IoC篇之统一资源加载Resource和ResourceLoader</a></li>
<li><a target="_blank" rel="noopener" href="http://cmsblogs.com/?p=2656">【死磕 Spring】—– IOC 之 Spring 统一资源加载策略</a></li>
</ul>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>代号十三<br>
        <strong>本文链接：</strong><a href="https://code-13.github.io/blogs/5eef8624.html" title="https:&#x2F;&#x2F;code-13.github.io&#x2F;blogs&#x2F;5eef8624.html" target="_blank" rel="noopener">https:&#x2F;&#x2F;code-13.github.io&#x2F;blogs&#x2F;5eef8624.html</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/Spring-framework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Spring-framework源码分析</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Spring/" rel="tag">Spring</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Spring-framework/" rel="tag">Spring-framework</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'f3372034aa4218f9f359',
        clientSecret: '235d14468b5af5837a9ff5e7b7541e93070cf602',
        id: window.location.pathname,
        repo: 'code-13.github.io',
        owner: 'code-13',
        admin: 'code-13'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%92%8C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5"><span class="toc-number">1.</span> <span class="toc-text">关于统一资源和资源加载策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90-Resource"><span class="toc-number">2.</span> <span class="toc-text">统一资源 Resource</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">Resource 接口定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Resource 继承体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractResource"><span class="toc-number">2.3.</span> <span class="toc-text">AbstractResource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD-ResourceLoader"><span class="toc-number">3.</span> <span class="toc-text">统一资源加载 ResourceLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceLoader%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">ResourceLoader接口定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceLoader-%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">ResourceLoader 的继承体系结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultResourceLoader"><span class="toc-number">3.3.</span> <span class="toc-text">DefaultResourceLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DefaultResourceLoader-%E7%9A%84%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">3.3.1.</span> <span class="toc-text">DefaultResourceLoader 的内部属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DefaultResourceLoader-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">DefaultResourceLoader 的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProtocolResolver-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text">ProtocolResolver 自定义的资源加载策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getResource-%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">getResource() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9A%E4%BD%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.5.</span> <span class="toc-text">完整的加载定位策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileSystemResourceLoader"><span class="toc-number">3.4.</span> <span class="toc-text">FileSystemResourceLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassRelativeResourceLoader"><span class="toc-number">3.5.</span> <span class="toc-text">ClassRelativeResourceLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourcePatternResolver"><span class="toc-number">3.6.</span> <span class="toc-text">ResourcePatternResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PathMatchingResourcePatternResolver"><span class="toc-number">3.7.</span> <span class="toc-text">PathMatchingResourcePatternResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">3.7.1.</span> <span class="toc-text">构造函数和属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getResource-%E6%96%B9%E6%B3%95-1"><span class="toc-number">3.7.2.</span> <span class="toc-text">getResource 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getResources-%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.3.</span> <span class="toc-text">getResources 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findAllClassPathResources-%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.4.</span> <span class="toc-text">findAllClassPathResources() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findPathMatchingResources-%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.5.</span> <span class="toc-text">findPathMatchingResources() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#determineRootDir-%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.6.</span> <span class="toc-text">determineRootDir()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doFindPathMatchingXxxResources-%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.7.</span> <span class="toc-text">doFindPathMatchingXxxResources() 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1640337217089"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
